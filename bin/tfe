#!/bin/sh

## -------------------------------------------------------------------
##
## tfe: Use the Terraform Enterprise API to perform operations in TFE
##
## -------------------------------------------------------------------
##
## Copyright (c) 2018 HashiCorp. All Rights Reserved.
##
## This file is provided to you under the Mozilla Public License
## Version 2.0 (the "License"); you may not use this file
## except in compliance with the License.  You may obtain
## a copy of the License at
##
##   https://www.mozilla.org/en-US/MPL/2.0/
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##
## -------------------------------------------------------------------

# The following variables will be set for the purpose of aiding subcommands. All
# bets are off for any other variables used in this script before subcommands
# are executed.
#
# tfe_cmd_dir
# tfe_payload_dir
# tfe_tar_verbose
# tfe_curl_silent
# tfe_address
# tfe_org
# tfe_workspace
# tfe_token

##
## Utility function declarations
##

# Print messages to stderr. Use printf to ensure the message is verbatim.
# E.g. do not interpret \n in JSON.
echoerr () { printf "%s\n" "$@" 1>&2; }

# Print debug messages if the TF_LOG environment variable is set.
echodebug () { [ -n "$TF_LOG" ] && echoerr "$@"; return 0; }

# Return (print) $1\n$2 if $1 is not empty. Usage:
#   my_str_list="$(append "$my_str_list" "line")"
# This will facilitate a later iteration:
#   echo "$my_str_list" | while read line; do <operations with "$line">; done
append () {
    printf "%s\n" "$( [ -n "$1" ] && printf "%s\n" "$1"; printf "%s\n" "$2" )"
}

# Remove specified files
cleanup () {
    if [ -n "$1" ]; then
        echo "$1" | while read f; do
            echodebug "[DEBUG] cleaning up $f"
            rm "$f" 2>&3
            if [ 0 -ne $? ]; then
                echoerr "Error cleaning up $f"
                echoerr "$f"
            fi
        done
    else
        echodebug "[DEBUG] No file to clean up"
    fi
}

# Usage description for options common to all subcommands
tfe_usage_args () {
cat << EOF
 -name <NAME>         The name of the Terraform Enterprise workspace,
                      formatted as "<ORGANIZATION>/<WORKSPACE>". If unspecified,
                      uses the TFE_ORG and TFE_WORKSPACE environment variables.

 -tfe-address <URL>   The address of your Terraform Enterprise instance.
                      Defaults to the SaaS hostname at https://app.terraform.io

 -token <TOKEN>       Access token for Terraform Enterprise API requests. If
                      unspecified, uses the ATLAS_TOKEN environment variable.

EOF
}

# Take two arguments; if the 2nd is empty then die
assign_arg () {
    if [ -z "$2" ] || [ "${2#-}" != "$2" ]; then
        echoerr "Parameter $1 is missing a value"
        # exit here will not terminate the script. Using PIPE
        # to kill the current process will not produce a kill
        # message
        kill -PIPE $$
    else
        echo $2
    fi
}

# Common options to curl. Fail on HTTP error codes.
tfe_api_call () {
    curl -f $tfe_curl_silent \
         --header "Authorization: Bearer $tfe_token" \
         --header "Content-Type: application/vnd.api+json" \
         $@
}

# Check the version of terraform in use. Commands can use this
# to verify that their use of Terraform will go as expected.
tf_version_required () {
    if [ $# -ne 3 ]; then
        echoerr "Unable to check the version of Terraform. This is a bug."
        exit 1
    fi

    # Verify the terraform command is present
    if [ -z "$(command -v terraform)" ]; then
        echoerr "The terraform command must be installed"
        exit 1
    fi

    # Test the version numbers provided in the output with the three arguments
    if ! terraform -version | awk -v major=$1 -v minor=$2 -v micro=$3 -F. '
        NR==1 {
            sub(/[^[0-9]*/, "", $1)
            if($1 > major) exit 0
            if($1 == major && $2 > minor) exit 0
            if($1 == major && $2 == minor && $3 >= micro) exit 0
            exit 1
        }'
    then
        echoerr "This operation requires at least Terraform $1.$2.$3"
        exit 1
    fi
}

check_required () {
    if [ all = "$1" ]; then
        check_for="tfe_org tfe_workspace tfe_token tfe_address"
    else
        check_for="$*"
    fi

    for i in $check_for; do
        case "$i" in
            tfe_org)
                if [ -z "$tfe_org" ]; then
                    missing=1
                    echoerr 'TFE organization required.'
                    echoerr 'Set with $TFE_ORG or use -name'
                    echoerr
                fi
            ;;
            tfe_workspace)
                if [ -z "$tfe_org" ]; then
                    missing=1
                    echoerr 'TFE workspace required.'
                    echoerr 'Set with $TFE_WORKSPACE or use -name'
                    echoerr
                fi
            ;;
            tfe_token)
                if [ -z "$tfe_token" ]; then
                    missing=1
                    echoerr 'TFE API token required.'
                    echoerr 'Set with $TFE_TOKEN, -token, or $ATLAS_TOKEN'
                    echoerr
                fi
            ;;
            tfe_address)
                # This really shouldn't happen. Someone would have to
                # explicitly pass in an empty string to the command line
                # argument.
                if [ -z "$tfe_address" ]; then
                    missing=1
                    echoerr 'TFE address required.'
                    echoerr 'Set with -tfe-address or $TFE_URL'
                    echoerr
                fi
            ;;
        esac
    done
    if [ 1 -eq $missing ]; then
        exit 1
    fi
}


execute_subcmd () {
    # Get the directory where the command should exist
    cmd_dir="$1"
    [ -n "$1" ] && shift

    if [ -z "$cmd_dir" ]; then
        echoerr "Error locating command."
        exit 1
    fi

    echodebug "[DEBUG] Command dir: $cmd_dir"

    # Get the command to find and run
    cmd="$1"
    [ -n "$1" ] && shift

    echodebug "[DEBUG] Command: $cmd"

    if [ -z "$cmd" ]; then
        tfe_help
        exit 1
    fi

    # Look for -h and friends, which are not actually advertised options, in
    # order to be helpful
    for arg in $@; do
        case "$arg" in
            -h|--help|-help)
                tfe_help "$cmd"
                exit 0
            ;;
        esac
    done

    # This allows for the help order to be reversed. So
    #     tfe help pushconfig
    # and
    #     tfe pushconfig help
    # will give you the same thing
    if [ "help" = $cmd ]; then
        tfe_help $@
        exit $?
    fi

    # Make sure there's a commands directory
    if [ ! -d "$cmd_dir" ]; then
        echoerr "Error obtaining commands. Check:"
        echoerr "$cmd_dir"
        exit 1
    fi

    # Ensure the command exists
    if [ ! -f "$cmd_dir/$cmd" ]; then
        echoerr "Command '$cmd' not found. See 'tfe help' for usage."
        exit 1
    fi

    # Handle a special case of help dyslexia, e.g.:
    #   tfe pushconfig help
    if [ 1 -eq $# ] && [ "help" = "$1" ]; then
        echodebug "[DEBUG] Help swapped in argument list"

        # See if the cmd is actually a command that the user probably
        # wants help information for.
        if [ -f "$cmd_dir/$1" ]; then
            . "$cmd_dir/$cmd"
            tfe_${cmd}_help
            exit 0
        fi
    fi

    # Dispatch the command with all of the following arguments to the appropriate,
    # sourced function
    echodebug "[DEBUG] Loading command from $cmd_dir/$cmd"
    . "$cmd_dir/$cmd"
    tfe_$cmd $@
}

##
## Program begins here
##

echodebug "[DEBUG] $PWD"
echodebug "[DEBUG] $0 $*"

# Check for commands that must be present to function

for required_cmd in jq curl readlink; do
    if [ -z "$(command -v $required_cmd)" ]; then
        echoerr "The $required_cmd command must be installed"
        exit 1
    fi
done

# Use TMPDIR if it is set. If not, set it to /tmp
if [ -z "$TMPDIR" ]; then
    TMPDIR=/tmp
fi

# Strip the trailing / from TMPDIR if there is one
TMPDIR="$(echo "$TMPDIR" | sed 's#/$##')"

if [ -n "$TF_LOG" ]; then
    # Debugging. Print command errors and make them verbose
    tfe_tar_verbose=v
    tfe_curl_silent=
    exec 3>&2
else
    # Not debugging. Shut everyting up.
    tfe_tar_verbose=
    tfe_curl_silent="-s"
    exec 3>/dev/null
fi

# Allow setting the URL to TFE with TFE_URL
tfe_address=${TFE_URL:-"https://app.terraform.io"}

# Allow setting the TFE organization with TFE_ORG
tfe_org="$TFE_ORG"

# Allow setting the TFE workspace with TFE_WORKSPACE
tfe_workspace="$TFE_WORKSPACE"

# Prefer TFE_TOKEN, fall back to ATLAS_TOKEN.
# Keep going if it's not set - can be set by -token
tfe_token="$TFE_TOKEN"
if [ -z "$tfe_token" ]; then
    tfe_token="$ATLAS_TOKEN"
fi

# Need to determine the script location and prefix to the needed lib directory.
# The prefix should be the directory that contains the bin and lib directories.
# i.e. /users/username/gitclones/terraform-enterprise-push (contains lib/tfe/)
#      /usr (contains bin/tfe and lib/tfe/)

# Note that this is not POSIX but portable to many systems with nearly any
# kind of implementation of readlink. We already require jq and curl, so
# requiring readline is not that big of a deal.

# Get the command used to start this script
target=$0

# If executing via a series of symlinks, resolve them all the way back to the
# script itself. Some danger here of infinitely cycling.
while [ -h "$target" ]; do
    link=$(readlink "$target")
    if [ "$(echo "$link" | cut -c -1)" = "/" ]; then
        # link path is absolute, just need to follow it
        target="$link"
    else
        # link path is relative, need to relatively follow it
        target="${target%/*}"
        target="$target/$link"
    fi
done

# Now target should be like the following, where 'script' is not a symlink:
# /some/path/to/the/actual/script

# Get the script name by removing everything up to the last /
bin_name="${target##*/}"

# Get the script path, go there, and resolve the full path of symlinks with pwd
tfe_prefix=$(cd ${target%/$bin_name} && pwd -P)

# Remove /bin and /sbin from the prefix if there is one (i.e. /usr/bin)
tfe_prefix=${tfe_prefix%/bin}
tfe_prefix=${tfe_prefix%/sbin}

# tfe_prefix should now be to something like /usr or
# /path/to/gitclone/terraform-enterprise-push

# Set some additional convenience variables
tfe_cmd_dir="$tfe_prefix/lib/tfe/commands"
tfe_payload_dir="$tfe_prefix/share/tfe/commands"

# Make sure there's a commands directory
if [ ! -d "$tfe_cmd_dir" ]; then
    echoerr "Error obtaining commands. Check:"
    echoerr "$tfe_cmd_dir"
    exit 1
fi

# Make sure we can load help so it is alwasy available.
# If not, that's a red flag.
if [ -f "$tfe_cmd_dir/help" ] ; then
    . "$tfe_cmd_dir/help"
else
    error_msg "Could not load essential commands. Please check your paths."
    exit 1
fi

# These help invocations are handled as a special case
case "$1" in
    -h|--help|-help)
        cmd_dir="$tfe_cmd_dir"
        tfe_help
        exit 0
    ;;
esac

# Now, if we haven't exited:
#   First argument is a command
#   Additional arguments are parameters to the command to be run

# Comb through options for name, token, and address while building
# a list of other arguments to go to the subcommand

subcmd_args=

while [ -n "$1" ]; do
    case "$1" in
        -tfe-address)
            tfe_address=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        -name)
            tfe_name=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        -token)
            tfe_token=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        *)
            subcmd_args="$subcmd_args $1"
            [ -n "$1" ] && shift
            ;;
    esac
done

# Try to assign required values

# Did we get org and workspace from the environment?
if [ -z "$tfe_org" ] && [ -z "$tfe_workspace" ]; then
    # No. Did we get it from -name?
    if [ -n "$tfe_name" ]; then
        # Separate the org and workspace in name
        tfe_org="${tfe_name%/*}"
        tfe_workspace="${tfe_name#*/}"
    fi
fi

# Run the subcommand with the remaining arguments
execute_subcmd "$tfe_cmd_dir" $subcmd_args

# Exit with the exit code returned by the command
exit $?

