#!/bin/sh

## -------------------------------------------------------------------
##
## tfe: Use the Terraform Enterprise API to perform operations in TFE
##
## -------------------------------------------------------------------
##
## Copyright (c) 2018 HashiCorp. All Rights Reserved.
##
## This file is provided to you under the Mozilla Public License
## Version 2.0 (the "License"); you may not use this file
## except in compliance with the License.  You may obtain
## a copy of the License at
##
##   https://www.mozilla.org/en-US/MPL/2.0/
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##
## -------------------------------------------------------------------

# The following variables will be set for the purpose of aiding subcommands. All
# bets are off for any other variables used in this script before subcommands
# are executed.
#
# tfe_cmd_dir
# tfe_payload_dir
# tfe_tar_verbose
# tfe_curl_silent
# tfe_address
# tfe_org
# tfe_workspace
# tfe_token

##
## Utility function declarations
##

# Print messages to stderr. Use printf to ensure the message is verbatim.
# E.g. do not interpret \n in JSON.
echoerr () { printf "%s\n" "$@" 1>&2; }

# Print debug messages if the TF_LOG environment variable is set.
echodebug () { [ -n "$TF_LOG" ] && echoerr "$@"; return 0; }

# Return (print) $1\n$2 if $1 is not empty. Usage:
#   my_str_list="$(append "$my_str_list" "line")"
# This will facilitate a later iteration:
#   echo "$my_str_list" | while read line; do <operations with "$line">; done
append () {
    printf "%s\n" "$( [ -n "$1" ] && printf "%s\n" "$1"; printf "%s\n" "$2" )"
}

# Remove specified files
cleanup () {
    if [ -n "$1" ]; then
        echo "$1" | while read f; do
            echodebug "[DEBUG] cleaning up $f"
            rm "$f" 2>&3
            if [ 0 -ne $? ]; then
                echoerr "Error cleaning up $f"
                echoerr "$f"
            fi
        done
    else
        echodebug "[DEBUG] No file to clean up"
    fi
}

# Usage description for options common to all subcommands
tfe_usage_args () {
cat << EOF
 -name <NAME>         The name of the Terraform Enterprise workspace,
                      formatted as "<ORGANIZATION>/<WORKSPACE>". If unspecified,
                      uses the TFE_ORG and TFE_WORKSPACE environment variables.

 -tfe-address <URL>   The address of your Terraform Enterprise instance.
                      Defaults to the SaaS hostname at https://app.terraform.io

 -token <TOKEN>       Access token for Terraform Enterprise API requests. If
                      unspecified, uses the ATLAS_TOKEN environment variable.

EOF
}

# Take two arguments; if the 2nd is empty then die
assign_arg () {
    if [ -z "$2" ] || [ "${2#-}" != "$2" ]; then
        echoerr "Parameter $1 is missing a value"
        # exit here will not terminate the script. Using PIPE
        # to kill the current process will not produce a kill
        # message
        kill -PIPE $$
    else
        echo $2
    fi
}

# Common options to curl. Fail on HTTP error codes.
tfe_api_call () {
    curl -f $tfe_curl_silent \
         --header "Authorization: Bearer $tfe_token" \
         --header "Content-Type: application/vnd.api+json" \
         $@
}

##
## Program begins here
##

echodebug "[DEBUG] $PWD"
echodebug "[DEBUG] $0 $*"

# Check for commands that must be present to function

for required_cmd in jq curl readlink; do
    if [ -z "$(command -v $required_cmd)" ]; then
        echoerr "The $required_cmd command must be installed"
        exit 1
    fi
done

# Use TMPDIR if it is set. If not, set it to /tmp
if [ -z "$TMPDIR" ]; then
    TMPDIR=/tmp
fi

# Strip the trailing / from TMPDIR if there is one
TMPDIR="$(echo "$TMPDIR" | sed 's#/$##')"

if [ -n "$TF_LOG" ]; then
    # Debugging. Print command errors and make them verbose
    tfe_tar_verbose=v
    tfe_curl_silent=
    exec 3>&2
else
    # Not debugging. Shut everyting up.
    tfe_tar_verbose=
    tfe_curl_silent="-s"
    exec 3>/dev/null
fi

# Allow setting the URL to TFE with TFE_URL
tfe_address=${TFE_URL:-"https://app.terraform.io"}

# Allow setting the TFE organization with TFE_ORG
tfe_org="$TFE_ORG"

# Allow setting the TFE workspace with TFE_WORKSPACE
tfe_workspace="$TFE_WORKSPACE"

# Prefer TFE_TOKEN, fall back to ATLAS_TOKEN.
# Keep going if it's not set - can be set by -token
tfe_token="$TFE_TOKEN"
if [ -z "$tfe_token" ]; then
    tfe_token="$ATLAS_TOKEN"
fi

# Need to determine the script location and prefix to the needed lib directory.
# The prefix should be the directory that contains the bin and lib directories.
# i.e. /users/username/gitclones/terraform-enterprise-push (contains lib/tfe/)
#      /usr (contains bin/tfe and lib/tfe/)

# Note that this is not POSIX but portable to many systems with nearly any
# kind of implementation of readlink. We already require jq and curl, so
# requiring readline is not that big of a deal.

# Get the command used to start this script
target=$0

# If executing via a series of symlinks, resolve them all the way back to the
# script itself. Some danger here of infinitely cycling.
while [ -h "$target" ]; do
    link=$(readlink "$target")
    if [ "$(echo "$link" | cut -c -1)" = "/" ]; then
        # link path is absolute, just need to follow it
        target="$link"
    else
        # link path is relative, need to relatively follow it
        target="${target%/*}"
        target="${target}/${link}"
    fi
done

# Now target should be like the following, where 'script' is not a symlink:
# /some/path/to/the/actual/script

# Get the script name by removing everything up to the last /
bin_name="${target##*/}"

# Get the script path, go there, and resolve the full path of symlinks with pwd
tfe_prefix=$(cd ${target%/$bin_name} && pwd -P)

# Remove /bin and /sbin from the prefix if there is one (i.e. /usr/bin)
tfe_prefix=${tfe_prefix%/bin}
tfe_prefix=${tfe_prefix%/sbin}

# tfe_prefix should now be to something like /usr or
# /path/to/gitclone/terraform-enterprise-push

# Set some additional convenience variables
tfe_cmd_dir="${tfe_prefix}/lib/tfe/commands"
tfe_payload_dir="${tfe_prefix}/share/tfe/commands"

# Make sure there's a commands directory
if [ ! -d "${tfe_cmd_dir}" ]; then
    echoerr "Error obtaining commands. Check:"
    echoerr "${tfe_cmd_dir}"
    exit 1
fi

# The help command is handled as a special case to cope with incorrect
# invocations.

# Make sure we can load help. If not, that's a red flag.
if [ -f "${tfe_cmd_dir}/help" ] ; then
    . "${tfe_cmd_dir}/help"
else
    error_msg "Could not load essential commands. Please check your paths."
    exit 1
fi

# No command was supplied. Try to error out helpfully.
if [ 0 -eq $# ]; then
    tfe_help
    exit 1
fi

# At least one argument given. If is help, run help with any arguments supplied.
# Exit with help's return value.
if [ "help" = $1 ]; then
    [ -n "$1" ] && shift
    tfe_help $@
    exit $?
fi

# Now, if we haven't exited:
#   First argument is a command
#   Additional arguments are parameters to the command to be run

# Pop the command
cmd="$1"
[ -n "$1" ] && shift

# Ensure the command exists
if [ ! -f "$tfe_cmd_dir/$cmd" ]; then
    echoerr "Command '$cmd' not found. See 'tfe help' for usage."
    exit 1
fi

# Handle a special case of help dyslexia, e.g.:
#   tfe pushconfig help
if [ 1 -eq $# ] && [ "help" = "$1" ]; then
    # See if the cmd is actually a command that the user probably
    # wants help information for.
    if [ -f "$tfe_cmd_dir/$1" ]; then
        . "$tfe_cmd_dir/$cmd"
        tfe_${cmd}_help
        exit 0
    fi
fi

# Comb through options for name, token, and address while building
# a list of other arguments to go to the subcommand

subcmd_args=

while [ -n "$1" ]; do
    case "$1" in
        -tfe-address)
            tfe_address=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        -name)
            tfe_name=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        -token)
            tfe_token=$(assign_arg "$1" "$2")
            [ -n "$1" ] && shift
            [ -n "$1" ] && shift
            ;;
        *)
            subcmd_args="$subcmd_args $1"
            [ -n "$1" ] && shift
            ;;
    esac
done

# Check for required values

# Did we get org and workspace from the environment?
if [ -z "$tfe_org" ] && [ -z "$tfe_workspace" ]; then
    # No. Did we get it from -name?
    if [ -z "$tfe_name" ]; then
        # No.
        echoerr 'Org and workspace required.'
        echoerr 'Set with $TFE_ORG and $TFE_WORKSPACE or use -name'
        exit 1
    else
        # Separate the org and workspace in name
        tfe_org="${tfe_name%/*}"
        tfe_workspace="${tfe_name#*/}"
    fi
fi

# Org and workspace could still be possibly unset if they're malformed
if [ -z "$tfe_org" ] || [ -z "$tfe_workspace" ]; then
    echoerr 'Org and workspace required.'
    echoerr 'Set with $TFE_ORG and $TFE_WORKSPACE or use -name'
    exit 1
fi

if [ -z "$tfe_token" ]; then
    echoerr 'Set the API token with $TFE_TOKEN, -token, or $ATLAS_TOKEN'
    exit 1
fi

# This really shouldn't happen. Someone would have to explicitly pass in
# an empty string to the command line argument.
if [ -z "$tfe_address" ]; then
    echoerr 'TFE address was not set'
    exit 1
fi

# Dispatch the command with all of the following arguments to the appropriate,
# sourced function
. "$tfe_cmd_dir/$cmd"
tfe_$cmd $subcmd_args

# Exit with the exit code returned by the command
exit $?

